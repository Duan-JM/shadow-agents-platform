# 阶段三：复刻 API 后端核心功能

## 目标
重写 Dify 的 API 后端，实现核心业务功能，包括用户认证、应用管理、工作流引擎、知识库系统等。所有代码注释使用中文，移除原作者信息。

---

## 总体思路

### 实现策略
1. **自底向上**：先实现基础层（数据模型、工具库），再实现业务层
2. **模块化开发**：每个模块独立开发和测试
3. **参考不抄袭**：理解原理后重新实现，不直接复制代码
4. **简化优先**：去除非核心功能，保持代码简洁

### 开发顺序
```
数据模型层 → 数据访问层 → 服务层 → 控制器层 → 核心业务逻辑
```

---

## 详细执行步骤

### 步骤 1：搭建基础设施

#### 1.1 配置管理模块

**`api/configs/app_config.py`**
```python
"""
应用配置模块
集中管理所有配置项
"""
import os
from typing import Optional

class Config:
    """应用基础配置"""
    
    # 应用信息
    APP_NAME = "Shadow Agents Platform"
    APP_VERSION = "0.1.0"
    
    # Flask 配置
    SECRET_KEY = os.getenv("SECRET_KEY", "change-this-secret-key-in-production")
    DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    
    # 数据库配置
    SQLALCHEMY_DATABASE_URI = os.getenv(
        "DATABASE_URL",
        "postgresql://shadow:shadow123456@localhost:5432/shadow_agents"
    )
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ECHO = DEBUG
    
    # Redis 配置
    REDIS_URL = os.getenv("REDIS_URL", "redis://:shadow123456@localhost:6379/0")
    
    # Celery 配置
    CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", REDIS_URL)
    CELERY_RESULT_BACKEND = CELERY_BROKER_URL
    
    # 文件存储配置
    STORAGE_TYPE = os.getenv("STORAGE_TYPE", "local")  # local, s3, minio
    STORAGE_LOCAL_PATH = os.getenv("STORAGE_LOCAL_PATH", "./storage")
    
    # JWT 配置
    JWT_SECRET_KEY = SECRET_KEY
    JWT_ACCESS_TOKEN_EXPIRES = int(os.getenv("JWT_ACCESS_TOKEN_EXPIRES", "3600"))  # 1小时
    JWT_REFRESH_TOKEN_EXPIRES = int(os.getenv("JWT_REFRESH_TOKEN_EXPIRES", "2592000"))  # 30天
    
    # CORS 配置
    CORS_ALLOW_ORIGINS = os.getenv("CORS_ALLOW_ORIGINS", "*").split(",")
    
    # 日志配置
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"


class DevelopmentConfig(Config):
    """开发环境配置"""
    DEBUG = True


class ProductionConfig(Config):
    """生产环境配置"""
    DEBUG = False


# 根据环境变量选择配置
config_map = {
    "development": DevelopmentConfig,
    "production": ProductionConfig,
}

def get_config() -> Config:
    """获取当前环境配置"""
    env = os.getenv("FLASK_ENV", "development")
    return config_map.get(env, DevelopmentConfig)
```

#### 1.2 数据库扩展初始化

**`api/extensions/ext_database.py`**
```python
"""
数据库扩展
初始化 SQLAlchemy
"""
from flask_sqlalchemy import SQLAlchemy

# 创建 SQLAlchemy 实例
db = SQLAlchemy()

def init_app(app):
    """
    初始化数据库扩展
    
    Args:
        app: Flask 应用实例
    """
    db.init_app(app)
```

#### 1.3 Redis 扩展

**`api/extensions/ext_redis.py`**
```python
"""
Redis 扩展
用于缓存和队列
"""
import redis
from flask import Flask

# Redis 连接池
redis_client: redis.Redis = None

def init_app(app: Flask):
    """
    初始化 Redis 连接
    
    Args:
        app: Flask 应用实例
    """
    global redis_client
    
    redis_url = app.config.get("REDIS_URL")
    redis_client = redis.from_url(redis_url, decode_responses=True)
    
    # 测试连接
    try:
        redis_client.ping()
        app.logger.info("Redis 连接成功")
    except Exception as e:
        app.logger.error(f"Redis 连接失败: {str(e)}")
        raise
```

---

### 步骤 2：实现数据模型层

#### 2.1 基础模型类

**`api/models/base.py`**
```python
"""
基础数据模型
所有模型的父类
"""
from datetime import datetime
from extensions.ext_database import db

class BaseModel(db.Model):
    """
    基础模型类
    提供通用字段和方法
    """
    __abstract__ = True
    
    # 主键
    id = db.Column(db.String(36), primary_key=True)
    
    # 时间戳
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self) -> dict:
        """
        转换为字典
        
        Returns:
            dict: 模型数据字典
        """
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }
    
    def save(self):
        """保存到数据库"""
        db.session.add(self)
        db.session.commit()
    
    def delete(self):
        """从数据库删除"""
        db.session.delete(self)
        db.session.commit()
```

#### 2.2 用户账户模型

**`api/models/account.py`**
```python
"""
用户账户数据模型
"""
import uuid
from extensions.ext_database import db
from models.base import BaseModel
from werkzeug.security import generate_password_hash, check_password_hash

class Account(BaseModel):
    """
    用户账户表
    存储用户基本信息和认证数据
    """
    __tablename__ = "accounts"
    
    # 用户信息
    email = db.Column(db.String(255), nullable=False, unique=True, index=True)
    name = db.Column(db.String(255), nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    
    # 账户状态
    status = db.Column(db.String(20), nullable=False, default="active")  # active, banned, deleted
    
    # 角色和权限
    role = db.Column(db.String(20), nullable=False, default="user")  # admin, user
    
    # 个人资料
    avatar = db.Column(db.String(255))
    timezone = db.Column(db.String(50), default="UTC")
    language = db.Column(db.String(10), default="zh-Hans")
    
    def __init__(self, email: str, name: str, password: str):
        """
        初始化账户
        
        Args:
            email: 邮箱地址
            name: 用户名
            password: 明文密码
        """
        self.id = str(uuid.uuid4())
        self.email = email
        self.name = name
        self.set_password(password)
    
    def set_password(self, password: str):
        """
        设置密码（加密存储）
        
        Args:
            password: 明文密码
        """
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password: str) -> bool:
        """
        验证密码
        
        Args:
            password: 待验证的明文密码
            
        Returns:
            bool: 密码是否正确
        """
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f"<Account {self.email}>"
```

#### 2.3 应用模型

**`api/models/app.py`**
```python
"""
应用数据模型
"""
import uuid
from extensions.ext_database import db
from models.base import BaseModel

class App(BaseModel):
    """
    应用表
    存储用户创建的 AI 应用
    """
    __tablename__ = "apps"
    
    # 基本信息
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text)
    icon = db.Column(db.String(255))
    icon_background = db.Column(db.String(7))  # 颜色代码
    
    # 应用类型
    mode = db.Column(db.String(20), nullable=False)  # chat, completion, agent, workflow
    
    # 所属关系
    account_id = db.Column(db.String(36), db.ForeignKey("accounts.id"), nullable=False, index=True)
    
    # 状态
    status = db.Column(db.String(20), nullable=False, default="draft")  # draft, published, archived
    
    # 配置（存储 JSON）
    model_config = db.Column(db.JSON)
    
    # 关系
    account = db.relationship("Account", backref=db.backref("apps", lazy="dynamic"))
    
    def __init__(self, name: str, mode: str, account_id: str):
        """
        初始化应用
        
        Args:
            name: 应用名称
            mode: 应用类型
            account_id: 所属账户 ID
        """
        self.id = str(uuid.uuid4())
        self.name = name
        self.mode = mode
        self.account_id = account_id
    
    def __repr__(self):
        return f"<App {self.name}>"
```

#### 2.4 工作流模型

**`api/models/workflow.py`**
```python
"""
工作流数据模型
"""
import uuid
from extensions.ext_database import db
from models.base import BaseModel

class Workflow(BaseModel):
    """
    工作流表
    存储工作流定义
    """
    __tablename__ = "workflows"
    
    # 基本信息
    app_id = db.Column(db.String(36), db.ForeignKey("apps.id"), nullable=False, index=True)
    version = db.Column(db.String(20), nullable=False)
    
    # 工作流定义（存储 JSON）
    graph = db.Column(db.JSON, nullable=False)  # 节点和边的定义
    features = db.Column(db.JSON)  # 功能配置
    
    # 状态
    status = db.Column(db.String(20), nullable=False, default="draft")  # draft, published
    
    # 关系
    app = db.relationship("App", backref=db.backref("workflows", lazy="dynamic"))
    
    def __init__(self, app_id: str, version: str = "1.0"):
        """
        初始化工作流
        
        Args:
            app_id: 所属应用 ID
            version: 版本号
        """
        self.id = str(uuid.uuid4())
        self.app_id = app_id
        self.version = version
        self.graph = {"nodes": [], "edges": []}
    
    def __repr__(self):
        return f"<Workflow {self.id} v{self.version}>"
```

#### 2.5 数据集模型

**`api/models/dataset.py`**
```python
"""
数据集（知识库）数据模型
"""
import uuid
from extensions.ext_database import db
from models.base import BaseModel

class Dataset(BaseModel):
    """
    数据集表
    存储知识库信息
    """
    __tablename__ = "datasets"
    
    # 基本信息
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text)
    
    # 所属关系
    account_id = db.Column(db.String(36), db.ForeignKey("accounts.id"), nullable=False, index=True)
    
    # 配置
    indexing_technique = db.Column(db.String(20), nullable=False, default="high_quality")  # economy, high_quality
    
    # 统计信息
    doc_count = db.Column(db.Integer, default=0)
    
    # 关系
    account = db.relationship("Account", backref=db.backref("datasets", lazy="dynamic"))
    
    def __init__(self, name: str, account_id: str):
        """
        初始化数据集
        
        Args:
            name: 数据集名称
            account_id: 所属账户 ID
        """
        self.id = str(uuid.uuid4())
        self.name = name
        self.account_id = account_id
    
    def __repr__(self):
        return f"<Dataset {self.name}>"


class Document(BaseModel):
    """
    文档表
    存储上传到知识库的文档
    """
    __tablename__ = "documents"
    
    # 基本信息
    dataset_id = db.Column(db.String(36), db.ForeignKey("datasets.id"), nullable=False, index=True)
    name = db.Column(db.String(255), nullable=False)
    
    # 文件信息
    file_id = db.Column(db.String(255))
    file_type = db.Column(db.String(50))
    file_size = db.Column(db.Integer)
    
    # 处理状态
    indexing_status = db.Column(db.String(20), default="pending")  # pending, processing, completed, error
    
    # 分段统计
    segment_count = db.Column(db.Integer, default=0)
    
    # 关系
    dataset = db.relationship("Dataset", backref=db.backref("documents", lazy="dynamic"))
    
    def __init__(self, dataset_id: str, name: str):
        """
        初始化文档
        
        Args:
            dataset_id: 所属数据集 ID
            name: 文档名称
        """
        self.id = str(uuid.uuid4())
        self.dataset_id = dataset_id
        self.name = name
    
    def __repr__(self):
        return f"<Document {self.name}>"
```

---

### 步骤 3：实现服务层

#### 3.1 认证服务

**`api/services/auth_service.py`**
```python
"""
认证服务
处理用户注册、登录、Token 管理等
"""
import jwt
from datetime import datetime, timedelta
from typing import Optional, Tuple
from flask import current_app
from models.account import Account
from extensions.ext_database import db

class AuthService:
    """认证服务类"""
    
    @staticmethod
    def register(email: str, name: str, password: str) -> Tuple[bool, str, Optional[Account]]:
        """
        用户注册
        
        Args:
            email: 邮箱地址
            name: 用户名
            password: 密码
            
        Returns:
            Tuple[bool, str, Optional[Account]]: (成功标识, 消息, 用户对象)
        """
        # 检查邮箱是否已存在
        existing_user = Account.query.filter_by(email=email).first()
        if existing_user:
            return False, "邮箱已被注册", None
        
        # 创建新用户
        try:
            account = Account(email=email, name=name, password=password)
            account.save()
            return True, "注册成功", account
        except Exception as e:
            db.session.rollback()
            return False, f"注册失败: {str(e)}", None
    
    @staticmethod
    def login(email: str, password: str) -> Tuple[bool, str, Optional[dict]]:
        """
        用户登录
        
        Args:
            email: 邮箱地址
            password: 密码
            
        Returns:
            Tuple[bool, str, Optional[dict]]: (成功标识, 消息, Token数据)
        """
        # 查找用户
        account = Account.query.filter_by(email=email).first()
        if not account:
            return False, "用户不存在", None
        
        # 验证密码
        if not account.check_password(password):
            return False, "密码错误", None
        
        # 检查账户状态
        if account.status != "active":
            return False, "账户已被禁用", None
        
        # 生成 Token
        tokens = AuthService.generate_tokens(account.id)
        return True, "登录成功", tokens
    
    @staticmethod
    def generate_tokens(account_id: str) -> dict:
        """
        生成访问令牌和刷新令牌
        
        Args:
            account_id: 账户 ID
            
        Returns:
            dict: 包含 access_token 和 refresh_token 的字典
        """
        secret_key = current_app.config["JWT_SECRET_KEY"]
        
        # 生成访问令牌（短期）
        access_payload = {
            "account_id": account_id,
            "type": "access",
            "exp": datetime.utcnow() + timedelta(seconds=current_app.config["JWT_ACCESS_TOKEN_EXPIRES"])
        }
        access_token = jwt.encode(access_payload, secret_key, algorithm="HS256")
        
        # 生成刷新令牌（长期）
        refresh_payload = {
            "account_id": account_id,
            "type": "refresh",
            "exp": datetime.utcnow() + timedelta(seconds=current_app.config["JWT_REFRESH_TOKEN_EXPIRES"])
        }
        refresh_token = jwt.encode(refresh_payload, secret_key, algorithm="HS256")
        
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "expires_in": current_app.config["JWT_ACCESS_TOKEN_EXPIRES"]
        }
    
    @staticmethod
    def verify_token(token: str) -> Tuple[bool, Optional[str]]:
        """
        验证 Token
        
        Args:
            token: JWT Token
            
        Returns:
            Tuple[bool, Optional[str]]: (是否有效, 账户ID)
        """
        try:
            secret_key = current_app.config["JWT_SECRET_KEY"]
            payload = jwt.decode(token, secret_key, algorithms=["HS256"])
            return True, payload.get("account_id")
        except jwt.ExpiredSignatureError:
            return False, None
        except jwt.InvalidTokenError:
            return False, None
```

#### 3.2 应用服务

**`api/services/app_service.py`**
```python
"""
应用服务
处理应用的创建、更新、删除等操作
"""
from typing import Optional, List, Tuple
from models.app import App
from extensions.ext_database import db

class AppService:
    """应用服务类"""
    
    @staticmethod
    def create_app(
        name: str,
        mode: str,
        account_id: str,
        description: Optional[str] = None,
        icon: Optional[str] = None
    ) -> Tuple[bool, str, Optional[App]]:
        """
        创建应用
        
        Args:
            name: 应用名称
            mode: 应用类型
            account_id: 所属账户 ID
            description: 应用描述
            icon: 应用图标
            
        Returns:
            Tuple[bool, str, Optional[App]]: (成功标识, 消息, 应用对象)
        """
        # 验证应用类型
        valid_modes = ["chat", "completion", "agent", "workflow"]
        if mode not in valid_modes:
            return False, f"无效的应用类型，必须是: {', '.join(valid_modes)}", None
        
        try:
            # 创建应用
            app = App(name=name, mode=mode, account_id=account_id)
            if description:
                app.description = description
            if icon:
                app.icon = icon
            
            app.save()
            return True, "应用创建成功", app
        except Exception as e:
            db.session.rollback()
            return False, f"应用创建失败: {str(e)}", None
    
    @staticmethod
    def get_app(app_id: str) -> Optional[App]:
        """
        获取应用
        
        Args:
            app_id: 应用 ID
            
        Returns:
            Optional[App]: 应用对象，不存在则返回 None
        """
        return App.query.filter_by(id=app_id).first()
    
    @staticmethod
    def list_apps(account_id: str, status: Optional[str] = None) -> List[App]:
        """
        列出用户的应用
        
        Args:
            account_id: 账户 ID
            status: 应用状态过滤
            
        Returns:
            List[App]: 应用列表
        """
        query = App.query.filter_by(account_id=account_id)
        
        if status:
            query = query.filter_by(status=status)
        
        return query.order_by(App.created_at.desc()).all()
    
    @staticmethod
    def update_app(
        app_id: str,
        **kwargs
    ) -> Tuple[bool, str, Optional[App]]:
        """
        更新应用
        
        Args:
            app_id: 应用 ID
            **kwargs: 要更新的字段
            
        Returns:
            Tuple[bool, str, Optional[App]]: (成功标识, 消息, 应用对象)
        """
        app = App.query.filter_by(id=app_id).first()
        if not app:
            return False, "应用不存在", None
        
        try:
            # 更新允许的字段
            allowed_fields = ["name", "description", "icon", "icon_background", "status", "model_config"]
            for key, value in kwargs.items():
                if key in allowed_fields:
                    setattr(app, key, value)
            
            app.save()
            return True, "应用更新成功", app
        except Exception as e:
            db.session.rollback()
            return False, f"应用更新失败: {str(e)}", None
    
    @staticmethod
    def delete_app(app_id: str) -> Tuple[bool, str]:
        """
        删除应用
        
        Args:
            app_id: 应用 ID
            
        Returns:
            Tuple[bool, str]: (成功标识, 消息)
        """
        app = App.query.filter_by(id=app_id).first()
        if not app:
            return False, "应用不存在"
        
        try:
            app.delete()
            return True, "应用删除成功"
        except Exception as e:
            db.session.rollback()
            return False, f"应用删除失败: {str(e)}"
```

---

### 步骤 4：实现控制器层

#### 4.1 认证控制器

**`api/controllers/console/auth/login.py`**
```python
"""
登录控制器
处理用户登录相关的 HTTP 请求
"""
from flask import Blueprint, request, jsonify
from services.auth_service import AuthService

# 创建蓝图
bp = Blueprint("auth_login", __name__, url_prefix="/api/console/auth")

@bp.route("/login", methods=["POST"])
def login():
    """
    用户登录接口
    
    请求体:
        {
            "email": "user@example.com",
            "password": "password123"
        }
    
    返回:
        {
            "success": true,
            "message": "登录成功",
            "data": {
                "access_token": "xxx",
                "refresh_token": "xxx",
                "expires_in": 3600
            }
        }
    """
    # 获取请求数据
    data = request.get_json()
    email = data.get("email")
    password = data.get("password")
    
    # 验证必填字段
    if not email or not password:
        return jsonify({
            "success": False,
            "message": "邮箱和密码不能为空"
        }), 400
    
    # 调用服务层处理登录
    success, message, tokens = AuthService.login(email, password)
    
    if success:
        return jsonify({
            "success": True,
            "message": message,
            "data": tokens
        }), 200
    else:
        return jsonify({
            "success": False,
            "message": message
        }), 401


@bp.route("/register", methods=["POST"])
def register():
    """
    用户注册接口
    
    请求体:
        {
            "email": "user@example.com",
            "name": "用户名",
            "password": "password123"
        }
    
    返回:
        {
            "success": true,
            "message": "注册成功",
            "data": {
                "id": "xxx",
                "email": "user@example.com",
                "name": "用户名"
            }
        }
    """
    # 获取请求数据
    data = request.get_json()
    email = data.get("email")
    name = data.get("name")
    password = data.get("password")
    
    # 验证必填字段
    if not email or not name or not password:
        return jsonify({
            "success": False,
            "message": "邮箱、用户名和密码不能为空"
        }), 400
    
    # 调用服务层处理注册
    success, message, account = AuthService.register(email, name, password)
    
    if success:
        return jsonify({
            "success": True,
            "message": message,
            "data": {
                "id": account.id,
                "email": account.email,
                "name": account.name
            }
        }), 201
    else:
        return jsonify({
            "success": False,
            "message": message
        }), 400
```

#### 4.2 应用控制器

**`api/controllers/console/app/apps.py`**
```python
"""
应用管理控制器
处理应用的 CRUD 操作
"""
from flask import Blueprint, request, jsonify, g
from services.app_service import AppService
from libs.decorators import require_auth

# 创建蓝图
bp = Blueprint("console_apps", __name__, url_prefix="/api/console/apps")

@bp.route("", methods=["GET"])
@require_auth
def list_apps():
    """
    获取应用列表
    
    查询参数:
        status: 应用状态过滤（可选）
    
    返回:
        {
            "success": true,
            "data": [
                {
                    "id": "xxx",
                    "name": "应用名称",
                    "mode": "chat",
                    ...
                }
            ]
        }
    """
    # 获取当前用户 ID（由认证装饰器注入）
    account_id = g.account_id
    
    # 获取查询参数
    status = request.args.get("status")
    
    # 调用服务层获取应用列表
    apps = AppService.list_apps(account_id, status)
    
    return jsonify({
        "success": True,
        "data": [app.to_dict() for app in apps]
    }), 200


@bp.route("", methods=["POST"])
@require_auth
def create_app():
    """
    创建应用
    
    请求体:
        {
            "name": "应用名称",
            "mode": "chat",
            "description": "应用描述"
        }
    
    返回:
        {
            "success": true,
            "message": "应用创建成功",
            "data": {
                "id": "xxx",
                "name": "应用名称",
                ...
            }
        }
    """
    # 获取当前用户 ID
    account_id = g.account_id
    
    # 获取请求数据
    data = request.get_json()
    name = data.get("name")
    mode = data.get("mode")
    description = data.get("description")
    icon = data.get("icon")
    
    # 验证必填字段
    if not name or not mode:
        return jsonify({
            "success": False,
            "message": "应用名称和类型不能为空"
        }), 400
    
    # 调用服务层创建应用
    success, message, app = AppService.create_app(
        name=name,
        mode=mode,
        account_id=account_id,
        description=description,
        icon=icon
    )
    
    if success:
        return jsonify({
            "success": True,
            "message": message,
            "data": app.to_dict()
        }), 201
    else:
        return jsonify({
            "success": False,
            "message": message
        }), 400


@bp.route("/<app_id>", methods=["GET"])
@require_auth
def get_app(app_id: str):
    """
    获取单个应用详情
    
    返回:
        {
            "success": true,
            "data": {
                "id": "xxx",
                "name": "应用名称",
                ...
            }
        }
    """
    # 获取应用
    app = AppService.get_app(app_id)
    
    if not app:
        return jsonify({
            "success": False,
            "message": "应用不存在"
        }), 404
    
    # 验证权限（确保是用户自己的应用）
    if app.account_id != g.account_id:
        return jsonify({
            "success": False,
            "message": "无权访问此应用"
        }), 403
    
    return jsonify({
        "success": True,
        "data": app.to_dict()
    }), 200


@bp.route("/<app_id>", methods=["PUT"])
@require_auth
def update_app(app_id: str):
    """
    更新应用
    
    请求体:
        {
            "name": "新名称",
            "description": "新描述"
        }
    
    返回:
        {
            "success": true,
            "message": "应用更新成功",
            "data": {...}
        }
    """
    # 获取应用并验证权限
    app = AppService.get_app(app_id)
    if not app or app.account_id != g.account_id:
        return jsonify({
            "success": False,
            "message": "应用不存在或无权访问"
        }), 404
    
    # 获取更新数据
    data = request.get_json()
    
    # 调用服务层更新
    success, message, updated_app = AppService.update_app(app_id, **data)
    
    if success:
        return jsonify({
            "success": True,
            "message": message,
            "data": updated_app.to_dict()
        }), 200
    else:
        return jsonify({
            "success": False,
            "message": message
        }), 400


@bp.route("/<app_id>", methods=["DELETE"])
@require_auth
def delete_app(app_id: str):
    """
    删除应用
    
    返回:
        {
            "success": true,
            "message": "应用删除成功"
        }
    """
    # 获取应用并验证权限
    app = AppService.get_app(app_id)
    if not app or app.account_id != g.account_id:
        return jsonify({
            "success": False,
            "message": "应用不存在或无权访问"
        }), 404
    
    # 调用服务层删除
    success, message = AppService.delete_app(app_id)
    
    if success:
        return jsonify({
            "success": True,
            "message": message
        }), 200
    else:
        return jsonify({
            "success": False,
            "message": message
        }), 400
```

---

### 步骤 5：实现工具库和中间件

#### 5.1 认证装饰器

**`api/libs/decorators.py`**
```python
"""
装饰器工具
提供通用的装饰器函数
"""
from functools import wraps
from flask import request, jsonify, g
from services.auth_service import AuthService

def require_auth(f):
    """
    认证装饰器
    验证请求中的 JWT Token，并将账户 ID 注入到 g 对象
    
    用法:
        @bp.route("/protected")
        @require_auth
        def protected_route():
            account_id = g.account_id
            ...
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # 从请求头获取 Token
        auth_header = request.headers.get("Authorization")
        if not auth_header:
            return jsonify({
                "success": False,
                "message": "缺少认证令牌"
            }), 401
        
        # 解析 Token（格式：Bearer <token>）
        try:
            token = auth_header.split(" ")[1]
        except IndexError:
            return jsonify({
                "success": False,
                "message": "认证令牌格式错误"
            }), 401
        
        # 验证 Token
        valid, account_id = AuthService.verify_token(token)
        if not valid:
            return jsonify({
                "success": False,
                "message": "认证令牌无效或已过期"
            }), 401
        
        # 将账户 ID 注入到 g 对象
        g.account_id = account_id
        
        return f(*args, **kwargs)
    
    return decorated_function
```

#### 5.2 错误处理

**`api/libs/errors.py`**
```python
"""
错误处理模块
定义自定义异常类和错误处理器
"""

class BaseError(Exception):
    """基础错误类"""
    code = "UNKNOWN_ERROR"
    status_code = 500
    message = "未知错误"
    
    def __init__(self, message: str = None):
        if message:
            self.message = message
        super().__init__(self.message)


class ValidationError(BaseError):
    """验证错误"""
    code = "VALIDATION_ERROR"
    status_code = 400
    message = "数据验证失败"


class AuthenticationError(BaseError):
    """认证错误"""
    code = "AUTHENTICATION_ERROR"
    status_code = 401
    message = "认证失败"


class PermissionError(BaseError):
    """权限错误"""
    code = "PERMISSION_ERROR"
    status_code = 403
    message = "权限不足"


class NotFoundError(BaseError):
    """资源未找到错误"""
    code = "NOT_FOUND_ERROR"
    status_code = 404
    message = "资源不存在"


def register_error_handlers(app):
    """
    注册全局错误处理器
    
    Args:
        app: Flask 应用实例
    """
    @app.errorhandler(BaseError)
    def handle_base_error(error):
        """处理自定义错误"""
        return {
            "success": False,
            "code": error.code,
            "message": error.message
        }, error.status_code
    
    @app.errorhandler(404)
    def handle_not_found(error):
        """处理 404 错误"""
        return {
            "success": False,
            "code": "NOT_FOUND",
            "message": "请求的资源不存在"
        }, 404
    
    @app.errorhandler(500)
    def handle_internal_error(error):
        """处理 500 错误"""
        app.logger.error(f"Internal error: {str(error)}")
        return {
            "success": False,
            "code": "INTERNAL_ERROR",
            "message": "服务器内部错误"
        }, 500
```

---

### 步骤 6：更新应用工厂

更新 `app_factory.py` 以注册所有组件：

**`api/app_factory.py`**
```python
"""
Flask 应用工厂（完整版）
"""
from flask import Flask
from flask_cors import CORS
from configs.app_config import get_config
from extensions.ext_database import db, init_app as init_db
from extensions.ext_redis import init_app as init_redis
from libs.errors import register_error_handlers

def create_app() -> Flask:
    """创建 Flask 应用实例"""
    app = Flask(__name__)
    
    # 加载配置
    config = get_config()
    app.config.from_object(config)
    
    # 初始化扩展
    initialize_extensions(app)
    
    # 注册蓝图
    register_blueprints(app)
    
    # 注册错误处理
    register_error_handlers(app)
    
    return app

def initialize_extensions(app: Flask) -> None:
    """初始化 Flask 扩展"""
    # CORS
    CORS(app, origins=app.config["CORS_ALLOW_ORIGINS"])
    
    # 数据库
    init_db(app)
    
    # Redis
    init_redis(app)
    
    app.logger.info("所有扩展初始化完成")

def register_blueprints(app: Flask) -> None:
    """注册蓝图（路由）"""
    # 认证相关
    from controllers.console.auth.login import bp as auth_bp
    app.register_blueprint(auth_bp)
    
    # 应用管理
    from controllers.console.app.apps import bp as apps_bp
    app.register_blueprint(apps_bp)
    
    app.logger.info("所有蓝图注册完成")
```

---

## 开发检查清单

每完成一个模块，需要验证：

- [ ] 代码符合 PEP 8 规范
- [ ] 所有注释使用中文
- [ ] 移除了作者信息
- [ ] 函数有清晰的文档字符串
- [ ] 错误处理完善
- [ ] 数据验证充分
- [ ] 单元测试编写（可选）

## 下一步

完成后端核心功能后，进入：
👉 **阶段四：复刻 Web 前端应用**
